/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./script.js":
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
/***/ (() => {

eval("// const io = require('socket.io-client');\r\nvar socket = io();\r\nconsole.log(\" loaded script.js\");\r\nlet rooms = [];\r\nlet search, mainid, q, roomValue, requestOptions, contentInfo, timeline, time, tag, vidID, timerInterval;\r\nvidID=\"M7lc1UVf-VE\";\r\nvar player;\r\nlet id = [];\r\nlet title = [];\r\nfunction enterroom() {  //enter a particular room\r\n  console.log(\"executed enterroom function\");\r\n  socket.emit(\"joinRoom\", roomValue);\r\n}\r\n\r\nasync function query() { // get the search query from the input field\r\n  q = document.getElementById('search').value;\r\n  await getVideos(q); // Wait for getVideos to complete\r\n  processVideos();  // Process the videos after getVideos is completed\r\n}\r\nfunction changebutton() {\r\n  setTimeout(() => {\r\n    roomValue = document.getElementById('enterroom').value;\r\n    const submitButton = document.getElementById(\"submit\");\r\n    console.log(\"executing changebutton function\");\r\n    console.log(\"rooms array in changebutton:\", rooms);\r\n    console.log(\"roomValue in changebutton:\", roomValue);\r\n    if (rooms.includes(roomValue)) {\r\n      console.log(\"correct room\");\r\n      submitButton.onclick = enterroom;\r\n      submitButton.innerHTML = \"Enter Room\";\r\n    } else {\r\n      document.getElementById('enterroom').placeholder = \"wrong room id\";\r\n      submitButton.innerHTML = \"wrong room id\";\r\n      submitButton.onclick = null;\r\n    }\r\n  }, 500);\r\n}\r\n\r\nasync function getVideos(q) {\r\n  requestOptions = {\r\n    method: \"GET\",\r\n    redirect: \"follow\"\r\n  };\r\n\r\n  try {\r\n    response = await fetch(`https://www.googleapis.com/youtube/v3/search?key=AIzaSyBhp8ZjlUH43kCd47j9osQj67IYAchSdsI&q=${q}&type=video&regionCode=IN&part=snippet`, requestOptions);\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n\r\n    search = await response.json();  // Store the entire search result\r\n  } catch (error) {\r\n    console.error('Fetch error:', error);\r\n  }\r\n}\r\n\r\nfunction processVideos() {  //filter the required data from the received json object for future use \r\n  const videos = search.items.map(item => ({\r\n    videoId: item.id.videoId,\r\n    title: item.snippet.title\r\n  }));\r\n  console.log(search);\r\n  console.log(videos);\r\n  for (let i = 0; i < videos.length; i++) {\r\n    console.log(id[i] = videos[i].videoId);\r\n    console.log(title[i] = videos[i].title);\r\n  }\r\n  const videoList = document.getElementById('videoList'); // Assuming you have a <ul> element with id 'videoList'\r\n\r\n  videos.forEach((video, index) => {\r\n    const btn = document.createElement('button');\r\n    btn.textContent = video.title;\r\n    btn.addEventListener('click', () => playVideo(video));\r\n\r\n    const li = document.createElement('li');\r\n    li.appendChild(btn);\r\n\r\n    videoList.appendChild(li);\r\n\r\n    id[index] = video.videoId;\r\n    title[index] = video.title;\r\n  });\r\n}\r\n\r\nfunction playVideo(vid) {  //executed when one of the button in the list of buttons is clicked\r\n  socket.emit('videoPlay',vid); //tell other sockets about the new video object\r\n  h1 = document.querySelector('h1');\r\n  h1.textContent = vid.title;\r\n  id2 = vid.videoId;\r\n  getSeconds(id2); //get no of seconds for the new video\r\n  var tag = document.createElement('script');\r\n  tag.src = \"https://www.youtube.com/iframe_api\"; //load the youtubeiframe api\r\n  var firstScriptTag = document.getElementsByTagName('script')[0];\r\n  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n  player.videoId=id2; //assign the clicked button's video id to player\r\n  player.loadVideoById(id2); //load the video of the clicked buttons' video id\r\n}\r\n\r\nfunction playVideo2(vid) {  //executed when one of the button in the list of buttons is clicked\r\n  // socket.emit('videoPlay',vid);  //tell other sockets about the new video object\r\n  h1 = document.querySelector('h1');\r\n  h1.textContent = vid.title;\r\n  id2 = vid.videoId;\r\n  getSeconds(id2); //get no of seconds for the new video\r\n  var tag = document.createElement('script');\r\n  tag.src = \"https://www.youtube.com/iframe_api\"; //load the youtubeiframe api\r\n  var firstScriptTag = document.getElementsByTagName('script')[0];\r\n  firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\r\n  player.videoId=id2; //assign the clicked button's video id to player\r\n  player.loadVideoById(id2); //load the video of the clicked buttons' video id\r\n}\r\n\r\nasync function getSeconds(id2) { //2 functions to call getsec asynchronously with await attribute\r\n  await getSec(id2);\r\n}\r\nasync function getSec(id2) { //get the no. of seconds for new video\r\n  mainid = id2;\r\n  requestOptions = {\r\n    method: \"GET\",\r\n    redirect: \"follow\"\r\n  };\r\n  try {\r\n    response = await fetch(`https://www.googleapis.com/youtube/v3/videos?key=AIzaSyBhp8ZjlUH43kCd47j9osQj67IYAchSdsI&id=${mainid}&part=contentDetails`, requestOptions);\r\n    if (!response.ok) {\r\n      throw new Error('Network response was not ok');\r\n    }\r\n    else {\r\n      contentInfo = await response.json();  // store the video details for that id\r\n      seconds = iso8601DurationToSec(contentInfo.items[0].contentDetails.duration);\r\n      timeline=document.getElementById(\"timeline\");\r\n      timeline.max = seconds;\r\n    }\r\n  }\r\n  catch (error) {\r\n    console.error('Fetch error:', error);\r\n  }\r\n}\r\nfunction iso8601DurationToSec(duration) {\r\n  // Regular expression to match ISO 8601 duration format\r\n  const durationRegex = /^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$/;\r\n\r\n  const matches = duration.match(durationRegex);\r\n\r\n  if (!matches) {\r\n    throw new Error('Invalid ISO 8601 duration format');\r\n  }\r\n\r\n  // Extract duration components from regex matches\r\n  const years = matches[1] || 0;\r\n  const months = matches[2] || 0;\r\n  const days = matches[3] || 0;\r\n  const hours = matches[4] || 0;\r\n  const minutes = matches[5] || 0;\r\n  const seconds = matches[6] || 0;\r\n\r\n  // Calculate total duration in seconds\r\n  const totalSeconds =\r\n    parseFloat(years) * 31536000 +  // 1 year = 365 days\r\n    parseFloat(months) * 2592000 +   // 1 month = 30 days\r\n    parseFloat(days) * 86400 +\r\n    parseFloat(hours) * 3600 +\r\n    parseFloat(minutes) * 60 +\r\n    parseFloat(seconds);\r\n\r\n  return totalSeconds;\r\n}\r\n\r\n// Function to load the YouTube IFrame Player API\r\nfunction loadYouTubePlayerAPI(id2) {\r\n  console.log(\"youtubeplayerapi executing\");\r\n  onYouTubeIframeAPIReady(id2);\r\n}\r\n\r\n// Function to seek to a specific time in the video\r\nfunction seekToTime(time) {\r\n  console.log(\"seekToTime function called with seconds:\", time);\r\n  console.log(player);\r\n  if (player && typeof player.seekTo === 'function') {\r\n    player.seekTo(time, true); // Seek to the specified time in seconds\r\n  } else {\r\n    console.log(\"Player is not ready or seekTo method is not available\");\r\n  }\r\n}\r\n\r\n// Function called when the YouTube IFrame Player API is ready\r\nfunction onYouTubeIframeAPIReady() {\r\n  player = new YT.Player('youtubePlayer', {\r\n    height: '500vh',\r\n    width: '500vw',\r\n    videoId: vidID,\r\n    playerVars: {\r\n      'playsinline': 1,\r\n      'autoplay': 1,\r\n      'controls': 1,\r\n    },\r\n    events: {\r\n      'onReady': onPlayerReady,\r\n      'onStateChange': onPlayerStateChange\r\n    }\r\n  });\r\n}\r\n// Function called when the YouTube Player is ready\r\nfunction onPlayerReady(event) {\r\n  timeline = document.getElementById(\"timeline\").value;\r\n}\r\nfunction onPlayerStateChange(event) \r\n{\r\n  if(YT.PlayerState.PLAYING==2)\r\n  {\r\n    console.log(\"timer cleared\");\r\n    clearInterval(timerInterval);\r\n  }\r\n  else if (YT.PlayerState.PLAYING)\r\n  {\r\n    console.log(\"Player is playing\");\r\n    trackProgress();  \r\n  }\r\n}\r\nfunction trackProgress()\r\n{\r\n  timerInterval=setInterval(increaseTimeline(),1000);\r\n}\r\nfunction increaseTimeline()\r\n{\r\n  timeline.value=timeline.value + 1\r\n  console.log(\"timeline.value=\",timeline.value);\r\n}\r\n\r\n// Function to handle seek functionality\r\nfunction changeProgress() {\r\n  timeline = document.getElementById(\"timeline\").value;\r\n  console.log(\"timeline executed\", timeline);\r\n  if (!player) {\r\n    // // Load the YouTube IFrame Player API and then seek to the specified time\r\n    // loadYouTubePlayerAPI(()=> {\r\n    // });\r\n    console.log(\"player not initialised in changeprogress\");\r\n  } else {\r\n    // If the player is already initialized, directly seek to the specified time\r\n    seekToTime(timeline);\r\n    socket.emit('seekTime',timeline);\r\n  }\r\n}\r\n\r\nsocket.on('getrooms', (room) => {\r\n  rooms = room;\r\n  console.log(\"rooms check event executed . rooms=\", rooms); // This will be executed when the server emits the 'roomcheck' event\r\n});\r\nsocket.on(\"videoLoaded\",(vidObj)=>{\r\n  console.log(\"event received by:\", socket.id);\r\n  playVideo2(vidObj);\r\n});\r\nsocket.on(\"executeSubmitFunc\",()=>submit());\r\nsocket.on('seek',(timeline)=>seekToTime(timeline));\n\n//# sourceURL=webpack://public/./script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./script.js"]();
/******/ 	
/******/ })()
;